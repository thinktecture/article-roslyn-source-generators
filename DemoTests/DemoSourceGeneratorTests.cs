using System.Collections.Immutable;
using FluentAssertions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace DemoTests;

public class DemoSourceGeneratorTests
{
   [Fact]
   public void Should_generate_Items_property_with_2_items()
   {
      var input = @"
using DemoLibrary;

namespace DemoTests
{
   [EnumGeneration]
   public partial class ProductCategory
   {
      public static readonly ProductCategory Fruits = new(""Fruits"");
      public static readonly ProductCategory Dairy = new(""Dairy"");

      public string Name { get; }

      private ProductCategory(string name)
      {
         Name = name;
      }
   }
}
";

      var additionalFile = new TestAdditionalFile("Translations.json", @"
{
  ""ProductCategory"": {
    ""en"": ""Product category"",
    ""de"": ""Produktkategorie""
  }
}
");

      var generatedCode = GetGeneratedOutput(input, additionalFile);

      generatedCode.Should().NotBeNull();

      generatedCode!.FromDemoCodeGenerator.Should().Be(@"// <auto-generated />
#nullable enable

// generation counter: 1

using System.Collections.Generic;
using DemoLibrary;

namespace DemoTests
{
   [Translation(""en"", ""Product category"")]
   [Translation(""de"", ""Produktkategorie"")]
   partial class ProductCategory
   {
      private static IReadOnlyList<ProductCategory>? _items;
      public static IReadOnlyList<ProductCategory> Items => _items ??= GetItems();

      private static IReadOnlyList<ProductCategory> GetItems()
      {
         return new[] { Fruits, Dairy };
      }
   }
}
");

      generatedCode.FromNewtonsoftCodeGenerator.Should().Be(@"// <auto-generated />
#nullable enable

// generation counter: 1

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace DemoTests
{
   [JsonConverterAttribute(typeof(ProductCategoryNewtonsoftJsonConverter))]
   partial class ProductCategory
   {
      public class ProductCategoryNewtonsoftJsonConverter : JsonConverter<ProductCategory>
      {
         public override void WriteJson(JsonWriter writer, ProductCategory? value, JsonSerializer serializer)
         {
            if (value is null)
            {
               writer.WriteNull();
            }
            else
            {
               writer.WriteValue(value.Name);
            }
         }

         public override ProductCategory? ReadJson(JsonReader reader, Type objectType, ProductCategory? existingValue, bool hasExistingValue, JsonSerializer serializer)
         {
            var name = serializer.Deserialize<string?>(reader);

            return name is null
                      ? null
                      : ProductCategory.Items.SingleOrDefault(c => c.Name == name);
         }
      }
   }
}
");
   }

   private static GeneratedCode? GetGeneratedOutput(
      string sourceCode,
      params AdditionalText[] additionalFiles)
   {
      var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
      var references = AppDomain.CurrentDomain.GetAssemblies()
                                .Where(assembly => !assembly.IsDynamic)
                                .Select(assembly => MetadataReference.CreateFromFile(assembly.Location))
                                .Cast<MetadataReference>();

      var compilation = CSharpCompilation.Create("SourceGeneratorTests",
                                                 new[] { syntaxTree },
                                                 references,
                                                 new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
      var generator = new DemoSourceGenerator.DemoSourceGenerator();
      CSharpGeneratorDriver.Create(generator)
                           .AddAdditionalTexts(additionalFiles.ToImmutableArray())
                           .RunGeneratorsAndUpdateCompilation(compilation,
                                                              out var outputCompilation,
                                                              out var diagnostics);

      // optional
      diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error)
                 .Should().BeEmpty();

      if (outputCompilation.SyntaxTrees.Count() != 3)
         return null;

      return new GeneratedCode(outputCompilation.SyntaxTrees.Single(t => t.FilePath.Contains(".Main.g.cs")).ToString(),
                               outputCompilation.SyntaxTrees.Single(t => t.FilePath.Contains(".NewtonsoftJson.g.cs")).ToString());
   }
}
