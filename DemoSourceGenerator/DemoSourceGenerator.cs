using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DemoSourceGenerator;

[Generator]
public class DemoSourceGenerator : IIncrementalGenerator
{
   public void Initialize(IncrementalGeneratorInitializationContext context)
   {
      var enumTypes = context.SyntaxProvider
                             .CreateSyntaxProvider(CouldBeEnumerationAsync, GetEnumTypeOrNull)
                             .Where(type => type is not null)!
                             .Collect<ITypeSymbol>();

      context.RegisterSourceOutput(enumTypes, GenerateCode);
   }

   private static bool CouldBeEnumerationAsync(SyntaxNode syntaxNode, CancellationToken cancellationToken)
   {
      if (syntaxNode is not AttributeSyntax attribute)
         return false;

      var name = ExtractName(attribute.Name);

      if (name is not ("EnumGeneration" or "EnumGenerationAttribute"))
         return false;

      // "attribute.Parent" is "AttributeListSyntax"
      // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
      return attribute.Parent?.Parent is ClassDeclarationSyntax classDeclaration &&
             IsPartial(classDeclaration);
   }

   private static string? ExtractName(NameSyntax? name)
   {
      return name switch
      {
         SimpleNameSyntax ins => ins.Identifier.Text,
         QualifiedNameSyntax qns => qns.Right.Identifier.Text,
         _ => null
      };
   }

   private static ITypeSymbol? GetEnumTypeOrNull(GeneratorSyntaxContext context, CancellationToken cancellationToken)
   {
      var classDeclaration = (ClassDeclarationSyntax)context.Node.Parent!.Parent!;

      var type = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration) as ITypeSymbol;

      return type is null || !IsEnumeration(type) ? null : type;
   }

   public static bool IsPartial(ClassDeclarationSyntax classDeclaration)
   {
      return classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
   }

   public static bool IsEnumeration(ISymbol type)
   {
      return type.GetAttributes()
                 .Any(a => a.AttributeClass?.Name == "EnumGenerationAttribute" &&
                           a.AttributeClass.ContainingNamespace is
                           {
                              Name: "DemoLibrary",
                              ContainingNamespace.IsGlobalNamespace: true
                           });
   }

   private static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol> enumerations)
   {
      if (enumerations.IsDefaultOrEmpty)
         return;

      foreach (var type in enumerations.Distinct(SymbolEqualityComparer.Default).Cast<ITypeSymbol>())
      {
         context.CancellationToken.ThrowIfCancellationRequested();

         var code = GenerateCode(type);
         var typeNamespace = type.ContainingNamespace.IsGlobalNamespace ? null : $"{type.ContainingNamespace}.";

         context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
      }
   }

   private static string GenerateCode(ITypeSymbol type)
   {
      var ns = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToString();
      var name = type.Name;
      var items = GetItemNames(type);

      return @$"// <auto-generated />

using System.Collections.Generic;

{(ns is null ? null : $@"namespace {ns}
{{")}
   partial class {name}
   {{
      private static IReadOnlyList<{name}> _items;
      public static IReadOnlyList<{name}> Items => _items ??= GetItems();

      private static IReadOnlyList<{name}> GetItems()
      {{
         return new[] {{ {String.Join(", ", items)} }};
      }}
   }}
{(ns is null ? null : @"}
")}";
   }

   private static IEnumerable<string> GetItemNames(ITypeSymbol type)
   {
      return type.GetMembers()
                 .Select(m =>
                         {
                            if (!m.IsStatic || m.DeclaredAccessibility != Accessibility.Public || m is not IFieldSymbol field)
                               return null;

                            return SymbolEqualityComparer.Default.Equals(field.Type, type)
                                      ? field.Name
                                      : null;
                         })
                 .Where(field => field is not null)!;
   }
}
