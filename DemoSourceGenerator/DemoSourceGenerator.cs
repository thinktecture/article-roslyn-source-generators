using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace DemoSourceGenerator
{
   [Generator]
   public class DemoSourceGenerator : ISourceGenerator
   {
      public void Initialize(GeneratorInitializationContext context)
      {
         context.RegisterForSyntaxNotifications(() => new DemoSyntaxReceiver());
      }

      public void Execute(GeneratorExecutionContext context)
      {
         var receiver = (DemoSyntaxReceiver)context.SyntaxReceiver;

         foreach (var classDeclaration in receiver.Candidates)
         {
            var model = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree, true);
            var type = model.GetDeclaredSymbol(classDeclaration) as ITypeSymbol;

            if (type is null || !IsEnumeration(type))
               continue;

            var code = GenerateCode(type);
            context.AddSource($"{type.Name}_Generated.cs", code);
         }
      }

      public static bool IsEnumeration(ISymbol type)
      {
         return type.GetAttributes().Any(a => a.AttributeClass?.ToString() == "DemoLibrary.EnumGenerationAttribute");
      }

      private static string GenerateCode(ITypeSymbol type)
      {
         var ns = type.ContainingNamespace.ToString();
         var name = type.Name;
         var items = GetItemNames(type);

         return @$"// <auto-generated />

using System.Collections.Generic;

{(String.IsNullOrWhiteSpace(ns) ? null : $"namespace {ns}")}
{{
   partial class {name}
   {{
      private static IReadOnlyList<{name}> _items;
      public static IReadOnlyList<{name}> Items => _items ??= GetItems();

      private static IReadOnlyList<{name}> GetItems()
      {{
         return new[] {{ {String.Join(", ", items)} }};
      }}
   }}
}}
";
      }

      private static IEnumerable<string> GetItemNames(ITypeSymbol type)
      {
         return type.GetMembers()
                    .Select(m =>
                            {
                               if (!m.IsStatic || m.DeclaredAccessibility != Accessibility.Public || m is not IFieldSymbol field)
                                  return null;

                               return SymbolEqualityComparer.Default.Equals(field.Type, type)
                                         ? field.Name
                                         : null;
                            })
                    .Where(field => field is not null);
      }
   }
}
